Technology Stack (YouTube-Only MVP)
Based on our detailed discussions and the decision to focus the MVP solely on YouTube, here is the tech stack arrived at for the GuardianLens project:
1. Frontend (Web & Mobile UI):
Framework: Flutter
Language: Dart
Key Libraries:
State Management: Bloc/Cubit or Riverpod (Choose one based on team preference/project complexity).
Routing: GoRouter.
HTTP Client: dio (Recommended for features like interceptors).
Secure Storage: flutter_secure_storage (For API tokens).
Push Notifications: firebase_messaging.
2. Backend API:
Language/Framework: Python with FastAPI (Primary Recommendation).
Reasoning: Strong performance, excellent for building APIs, automatic OpenAPI docs, mature ecosystem, and crucially, direct access to powerful NLP/ML libraries for current/future analysis needs.
Alternatives: Node.js/NestJS (if team strongly prefers TypeScript), Go/Gin (for peak performance focus).
API Specification: OpenAPI (Swagger) (Auto-generated by FastAPI).
3. Database:
Primary Store: PostgreSQL (Managed service like AWS RDS, Google Cloud SQL recommended).
Caching Layer: Redis (Managed service like AWS ElastiCache, Google Memorystore recommended).
4. Analysis Engine (MVP):
Implementation: Integrated within the Python/FastAPI backend for MVP. Designed modularly for potential future separation.
Technique: Keyword/Pattern Matching on text metadata (channel/video titles & descriptions) using internal lists.
Libraries: Standard Python string matching, potentially spaCy or NLTK for basic text processing if needed. No external AI/LLM APIs or heavy ML models required for MVP analysis.
5. Asynchronous Tasks / Task Queue:
System: Celery
Message Broker: Redis (can use the same instance as the cache) or RabbitMQ.
Reasoning: Mature, powerful Python-native task queue system for handling background jobs like daily YouTube data fetching and analysis.
6. Authentication:
Parent Authentication: Token-based (JWT) managed by the backend.
Child Account Linking: Standard Google OAuth 2.0 flow requesting the youtube.readonly scope.
7. Notifications:
Push Notifications (Mobile): Firebase Cloud Messaging (FCM) (Triggered by backend).
Email Notifications: Backend service using an Email Provider API (e.g., AWS SES, SendGrid).
8. Deployment:
Flutter Web: Static hosting (Firebase Hosting, Vercel, S3+CloudFront, etc.).
Flutter Mobile: App Store Connect (iOS), Google Play Console (Android).
Backend/Analysis/Celery: Docker containers orchestrated via Kubernetes (EKS, GKE, AKS) or deployed to a PaaS (Cloud Run, App Runner, Heroku).
CI/CD: GitHub Actions, GitLab CI, Codemagic, Bitrise, etc.
Key Considerations Embedded in this Stack:
YouTube Only (MVP): This stack is tailored for the YouTube API integration, significantly simplifying the data acquisition layer compared to supporting multiple platforms initially.
API Quota Management: The critical dependency on YouTube API quotas is acknowledged. The stack relies on backend logic for aggressive caching (Redis) and efficient API call patterns.
Scalability: Choices like FastAPI, PostgreSQL, Redis, Celery, and Kubernetes/PaaS provide pathways for scaling.

9. Testing Tools & Frameworks:
*   **Backend Testing:** Pytest for unit and integration tests, with pytest-cov for coverage reporting.
*   **Frontend Testing:** Flutter's test package for unit tests, flutter_test for widget tests, and integration_test for end-to-end testing.
*   **API Testing:** Requests library with Pytest for API-level testing.
*   **Performance Testing:** Locust or k6 for API load testing.
*   **Security Testing:** Dependency scanning tools and SAST integration in CI pipeline.

For a detailed phased approach to testing implementation, refer to the [Comprehensive Testing Plan](../documentation/development-progress.md#comprehensive-testing-plan).
Modularity: Designing the Analysis Engine logic modularly within the Python backend allows for easier integration of more advanced techniques (like LLMs) post-MVP without rewriting the core backend.

